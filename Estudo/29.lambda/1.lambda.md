<h1 align="center">Lambda</h1>

## Functional Interface
Functional Interface √© uma interface que cont√©m apenas 1 abstract method (method sem corpo). Por ter apenas 1 method sem corpo, n√≥s podemos definir e corpo desse method e utiliz√°-lo, sem precisar criar uma Classe pra isso.

<br>

### Utilizando o method de uma interface da maneira tradicional

Imagine que vamos criar um method para printar(). A maneira tradicional seria:

1. Criamos uma Interface para criar a estrutura do nosso method.
2. Criamos uma Class que vai implements essa Interface, e vamos definir o corpo desse method.
3. Criamos um objeto dessa CLass e utilizamos o method.


```java
//Functional Interface
@FunctionalInterface //boas pr√°ticas. Sempre que temos uma interface com apenas 1 abstract method, ela √© uma "functional interface".
public interface InsaneInterface {

    //only 1 abstract method
    public void printMessage();
}



//Class para implementar a interface e setar o corpo do method
public class InsaneClass implements InsaneInterface{

    //method do contrato/interface
    @Override
    public void printMessage() {
        System.out.println("Salve!");
    }
}



//Main Class - Criamos um objeto da Class para conseguir usar o method
public class App{
    public static void main(String[] args){
        
        InsaneClass ic = new InsaneClass();
        ic.printMessage();
    }
}
```

<br>
<br>

### Chamando o method diretamente
Ao inv√©s de fazer dessa maneira tradicional, podemos deixar o c√≥digo mais clean.

Sem criar uma classe separada, voc√™ pode criar uma inst√¢ncia da interface e fornecer a implementa√ß√£o do m√©todo diretamente.

```java
public class App{
    public static void main(String[] args){
        
        InsaneInterface ii = new InsaneInterface() {

            //somos obrigados a setar o corpo desse method. √â como se tiv√©ssemos implementado a interface aqui.
            @Override
            public void printMessage() {
                System.out.println("Salve!");
            }
        };

        ii.printMessage();
    }
}
```

‚ö†Ô∏è S√≥ conseguimos instanciar uma interface se ela √© for uma functional interface (interface com apenas 1 abstract method). N√ÉO √© poss√≠vel instanciar/criar objetos de uma interface que contem varios abstract methods.

<br>
<br>

### Chamando o method diretamente, utilizando lambda üòé
Utilizando lambda expressions, podemos deixar isso ainda mais clean.

```java
public class App{
    public static void main(String[] args){
        
        InsaneInterface ii = () -> {
            System.out.println("Salve!");
            System.out.println("Salve!");
        };
        ii.printMessage();
    }
}
```
Se ligou? Com express√µes lambda, o c√≥digo fica mais conciso e f√°cil de entender. √â uma maneira pr√°tica de implementar m√©todos de functional interfaces. `() -> {}`


<hr>
<br>

## Syntax <img src="https://cdn-icons-png.flaticon.com/512/1442/1442581.png" alt="curly braces icon" width="30px" align="center">

```java
//sem parametros ...
() -> expression;
() -> {expression};

//apenas 1 parametro ...
parameter1 -> expression;
parameter1 -> {expressions};


////v√°rios parametros ...
(p1, p2, p3) -> expression;
(p1, p2, p3) -> {expressions};
```

‚úèÔ∏è Crie um exerc√≠cio para cada um dos exemplos acima.

```java

```