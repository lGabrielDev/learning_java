<h1 align="center">
    <img src="https://miro.medium.com/v2/resize:fit:786/format:webp/0*bLyBMf9G_dVm-sXU.png" alt="image example" width="500px"></img>
</h1>

## O que √© uma Stream?
Antigamente, para filtrar, ordenar, ou fazer qualquer outra operacao em uma estrutura de dados(List,Set,etc...) era muito complicado. Para facilitar isso, o **java stream** foi criado.

Usando Streams, voc√™ pode manipular, filtrar, mapear e processar dados de uma lista ou cole√ß√£o sem modificar os dados originais. Isso permite trabalhar de forma mais segura.

<hr>
<br>

## Syntax  <img src="https://cdn-icons-png.flaticon.com/512/1442/1442581.png" alt="curly braces icon" width="30px" align="center">

Sempre que estamos trabalhando com `stream()`, precisamos ter primeiro uma estrutura de dados (List, Set, etc...)


```java
public class App{
    public static void main(String[] args){
        
        List<Integer> numbers = List.of(1,4,33,2); //lista original
        Stream<Integer> numbersInsanos = numbers.stream(); //transformamos nossa lista em uma Stream (fluxo de dados)
        
        numbersInsanos.forEach(i -> System.out.println(i)); //i representa cada item da stream
    }
}
```

‚ö†Ô∏è Uma **stream** s√≥ pode ser usada apenas 1 vez. Para fazer outras operacoes, voce precisa criar outras streams.


<br>

Quando transformamos uma lista em uma stream, podemos usar v√°rios methods insanos para manipular dados. Esses methods s√£o divididos em 2 grupos:

1. **opera√ß√µes intermedi√°rias**:
	S√£o m√©todos que transformam a Stream em outra Stream. Elas permitem manipular os dados sem terminar o fluxo. Ex:
	
	- `filter()`
	- `map()`
	- `sorted()`

<br>

2. **opera√ß√£o terminal** (ultima operacao da stream):
	S√£o m√©todos que finalizam o fluxo da Stream e retornam um resultado ou executam uma a√ß√£o. Depois de uma opera√ß√£o terminal, a Stream n√£o pode ser usada novamente. Ex:

	- `forEach()`
	- `count()`
	- `collect()`

<hr>
<br>

## Entendendo por debaixo dos panos:

A maioria desses methods "liberados" quando usamos stream, recebem como argumento um objeto de uma Functional Interface. Ou seja, podemos usar lambda para preencher esses parametros.

Vamos usar o method `Filter()` como exemplo:


‚úèÔ∏è Crie uma lista simples de Integer e filtre apenas os n√∫meros pares:

### Instanciando uma functional interface de forma tradicional

```java
public class App{
    public static void main(String[] args){
        
        List<Integer> numbers = List.of(5,7,3,10,2); //lista original - nao vai sofrer alteracao
        Stream<Integer> streamInsana =  numbers.stream(); // stream para manipular os dados

        //filter() recebe como argumento um objeto do tipo/Class "Predicate"
        Predicate<Integer> predicateInsano = new Predicate<>() {
            @Override
            public boolean test(Integer n1){
                return n1 % 2 == 0; //even (par)
            };
        };

        //forEach() recebe como argumento um objeto do tipo/Class "Consumer"
        Consumer<Integer> consumerInsano = new Consumer<>(){
            @Override
            public void accept(Integer n1){
                System.out.println(n1);
            }
        };

        streamInsana
            .filter(predicateInsano)
            .forEach(consumerInsano);
    }
}
```

‚ö†Ô∏è Perceba que os argumentos que precisamos passar nos methods `filter()` and `forEach()` s√£o objetos de uma **Functional Interface**. Por isso instanciamos os objetos dessa forma.

<br>

### Instanciando uma functional interface usando lambda

```java
public class App{
    public static void main(String[] args){
        
        List<Integer> numbers = List.of(5,7,3,10,2); //lista original - nao vai sofrer alteracao
        Stream<Integer> streamInsana =  numbers.stream(); // stream para manipular os dados

        //filter() recebe como argumento um objeto do tipo/Class "Predicate"
        Predicate<Integer> predicateInsano = n1 -> n1 % 2 == 0;

        //forEach() recebe como argumento um objeto do tipo/Class "Consumer"
        Consumer<Integer> consumerInsano = n1 -> System.out.println(n1);

        streamInsana
            .filter(predicateInsano)
            .forEach(consumerInsano);
    }
}
```

Por estar instanciando um objeto de uma Functional Interface, podemos usar lambda e setar o unico abstract method que ela t√™m.

<br>

### Instanciando uma functional interface usando lambda diretamente

```java
public class App{
    public static void main(String[] args){
        
        List<Integer> numbers = List.of(5,7,3,10,2); //lista original - nao vai sofrer alteracao
        Stream<Integer> streamInsana =  numbers.stream(); // stream para manipular os dados

        streamInsana
            .filter(n1 -> n1 % 2 == 0) //criamos um Predicate na hora
            .forEach(n1 -> System.out.println(n1)); //criamos um Consumer na hora
    }
}
```
üòé Olha a diferen√ßa! Muito mais clean n√©?

<hr>
<br>

## Opera√ß√µes Intermedi√°rias

### `filter()`
Filtra os elementos da Stream com base em uma condi√ß√£o.

O method **filter()** recebe como argumento um objeto do tipo *Predicate* (functional interface).

<br>
<br>
<br>
<br>
<br>

<br>
<br>
<br>
<br>
<br>
<br>


<br>
<br>
<br>
<br>


<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<hr>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<hr>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<hr>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<hr>

Lembrando que a maioria dos methods de uma stream sao preenchidos utilizando **lambda expressions**. Isso, porque s√£o method que vieram de uma **functional interface**.

<hr>
<br>
<br>



<hr>
<br>
<br>

## Operacoes intermediarias

Os methods intermediarios mais usados em uma `stream()` s√£o:

- `filter()` --> Filtra deteminados dados
- `sorted(new ComparatorTal())` --> Ordena, com base no comparator que informamos
- `map()` --> extrai determinado campo/attribute


<br>
<br>



<br>

## Operacao final
Os methods finais mais usados em uma `stream()` s√£o:

- `.forEach()` --> Percorre todos os items da lista e executa um bloco de codigo.
- `.count()`--> Conta quantos items tem na lista.
- `.min(new AgeComparator());`--> Menor objeto (precisamos passar um comparator para escolher o attribute que vamos comparar).
- `.max(new AgeComparator());`--> Maior objeto (precisamos passar um comparator para escolher o attribute que vamos comparar).
- `.collect()` --> Coleta aquela abstracao de lista e transforma de fato em uma List/Set/Map. Pega essa abstracao e a transforma de fato em uma estrutura de dados.

<hr>
<br>
<br>

## Praticando:

### .filter()
EXPLICAR PASSO A PASSO O CONSUMER DE TODOS OS METHODS; PRA FICAR CLARO

O method filter retorna um booleano. Ou seja, se a condicao que colocarmos ali dentro for true, o item vai aparecer na lista.


‚úèÔ∏è Filtre apenas as "mulheres" e ordene-as pela idade

```java
//lista original
List<Person> persons = Arrays.asList(p1,p2,p3,p4);

//abstraindo e criando uma nova lista
List<Person> mulheres = persons.stream()
	.filter(p -> p.getSexo().equals(Gender.FEMALE)) //informamos o unico parametro () e depois informamos o body desse abstract method ->
	.sorted(new AgeComparator())
	.collect(Collectors.toList()); //transformamos em uma lista

mulheres.forEach(System.out::println);
```

Dale! Temos uma lista com apenas "mulheres".

<br>

‚ö†Ô∏è Sempre que estiver trabalhando com o `sorted()` e precise informar um `Comparator`, crie antes uma Comparator Class e informe `<T>` a Class que vamos comparar. Mesmo que seja uma Class Double, Integer, pode criar do mesmo jeito que d√° certo.

üìñ Sempre que quiser transformar a stream em uma lista, use o `.collect()` .

<hr>
<br>


### .max() .min()

‚úèÔ∏è Traga as seguintes informacoes:

- Pessoa mais velha
- Pessoa mais nova
- Pessoa que ganha mais
- Pessoa que ganha menos


```java
 //lista original
List<Person> persons = Arrays.asList(p1,p2,p3,p4);

//Pessoa mais velha:
Person pessoaMaisVelha = persons.stream()
	.max(new AgeComparator())
	.get();
System.out.println(pessoaMaisVelha);


//Pessoa mais nova:
Person pessoaMaisNova = persons.stream()
	.min(new AgeComparator())
	.get();
System.out.println(pessoaMaisNova);


//Pessoa que ganha mais
Person maiorSalario = persons.stream()
	.max(new SalaryComparator())
	.get();
System.out.println(maiorSalario);


//Pessoa que ganha menos
Person menorSalario = persons.stream()
	.min(new SalaryComparator())
	.get();
System.out.println(menorSalario);
```

Criamos "Person" porque esses methods retornam um Objeto apenas.


<hr>
<br>

### .map()
N√≥s usamos o `.map()` para informar quais os campos da lista que desejamos extrair. Al√©m disso, podemos alterar os valores dos campos.


- O method`.map()` recebe como parametro uma functional interface. Ou seja, podemos usar lambda.

- O method dessa functional interface, recebe apenas 1 parametro e retorna um objeto qualquer. Ou seja....

- Precisamos informar uma variable/objeto que representa cada item da lista, e depois retornar algum objeto. Ou seja, podemos retornar o objeto completo, ou extrair algum attribute desse objeto.

<br>

#### Criando uma lista de cada campo
Imagine que desejamos informar uma lista de pessoas, contendo apenas o campo "salary". Sacou?

‚úèÔ∏è Crie 1 lista para cada attribute de "Person"

```java
//lista de pessoas
List<Person> people = Arrays.asList(
	new Person("Zyra", 40, Gender.FEMALE, 3000d),
	new Person("Camila", 33, Gender.FEMALE, 4500d),
	new Person("Naruto", 31, Gender.MALE, 2000d),
	new Person("Sasuke", 29, Gender.MALE, 1900d)
);


//apenas "names"
List<String> names = people.stream()
	.map(p -> { //informamos uma variable/objeto representando cada item da lista.
		return p.getName(); //retornamos apenas o attribute "name"
	})
	.collect(Collectors.toList());



//apenas "ages"
List<Integer> ages = people.stream()
	.map(personAtual -> personAtual.getAge()) //assim, ele identifica o retorno automaticamente
	.collect(Collectors.toList());

//apenas "genders"
List<Gender> genders = people.stream()
	.map(p -> p.getSexo()) //informamos o objeto representando cada item da lista, depois informamos o objeto que desejamos retornar
	.distinct()
	.collect(Collectors.toList());


//apenas "salary"
List<Double> salaries = people.stream()
	.map(p -> {return p.getSalary();}) //informamos o objeto representando cada item da lista, depois informamos o objeto que desejamos retornar
	.collect(Collectors.toList());


System.out.println("Names:");
System.out.println(names);

System.out.println("\nAges:");
System.out.println(ages);

System.out.println("\nGenders:");
System.out.println(genders);

System.out.println("\nSalaries:");
System.out.println(salaries);

```
Se ligou??? Basta entender qual a functional interface que precisamos passar como parametro.

Quando usamos qualquer method do `.stream()`, como o `.filter()`, `.map()`, `.sort()`, etc... precisamos pensar:

- No `.map()`, eu preciso passar que argumento??
- Hmm.... Preciso passar uma functional interface...
- Logo, posso usar lambda para implementar aquela interface
- Logo, posso declarar o corpo do abstract method daquela interface

Sacou?

<br>
<br>

#### Criando uma lista com o objeto completo

```java
//lista original
List<Person> persons = Arrays.asList(p1,p2,p3,p4);


//Retornando uma lista de pessoa
List<Person> salarios = persons.stream()
	.map(p -> p) //informamos o objeto representando cada item da lista, depois informamos o objeto que desejamos retornar. Nesse caso, o proprio item da lista
	.collect(Collectors.toList());


System.out.println(" ======== Persons completas: ========");
salarios.forEach(System.out::println);
```


<br>
<br>
<br>

#### Alterando informacoes de alguns campos

O legal de trabalhar com `.map()` √© que podemos extrair determinados campos, como tambem alterar os valores desses campos.


Imagine o seguinte:

- Queremos adicionar no "name" de cada pessoa um "Sr(a)"
- Queremos dar um aumento de 30% no "salario" dessas pessoas


```java
 listaBolada.stream()
	.map(itemAtual -> { //informamos a variable/objeto representando cada item da lista
		Person p1 = new Person();
		p1.setName("Sr(a) " + itemAtual.getName());
		p1.setAge(itemAtual.getAge());
		p1.setSexo(itemAtual.getSexo());
		p1.setSalary(itemAtual.getSalary() + (itemAtual.getSalary() * 0.20));
		return p1; //retornamos esse objeto.
	})
	.sorted((p1, p2) -> {return p2.getName().compareTo(p1.getName());})
	.forEach(System.out::println);

```

Se ligou?? Quando estamos usando o  `.map()`, n√≥s precisamos informar um objeto que representa cada item da lista e depois informar qual o attribute desse item que queremos extrair/retornar.

<br>
<br>
<br>

#### .mapToDouble()

Quando temos um campo double ou int, podemos fazer calculos insanos:

‚úèÔ∏è Atrav√©s do campo sal√°rio, informe as seguintes informacoes:

- soma dos salarios
- media dos salarios
- maior salario
- menor salario

```java
//Soma dos salarios
Double somaSalarios = people.stream()
	.mapToDouble(item -> {return item.getSalary();})
	//esse method recebe como parametro uma functional interface...
	//Logo, podemos usar lambda para preencher seu unico abstract method.
	//Logo, esse abstract method recebe apenas 1 parametro generico, e retorna um Double.
	.sum();
	

//maior salario
Double maiorSalario = people.stream()
	.mapToDouble(person -> person.getSalary()) //informamos o parametro do abstract method, e depois setamos seu corpo. No caso, ele retorna um Double
	.max().getAsDouble();


//menor salario
Double menorSalario = people.stream()
	.mapToDouble(person -> person.getSalary())
	.min().getAsDouble();


//media dos salarios
Double average = people.stream()
	.mapToDouble(p -> {return p.getSalary();})
	.average().getAsDouble();
	

System.out.print("Soma salarios: R$ ");
System.out.println(somaSalarios);

System.out.print("\nMaior Salario: R$ ");
System.out.println(maiorSalario);

System.out.print("menor Salario: R$ ");
System.out.println(menorSalario);

System.out.print("Media salarios: R$ ");
System.out.println(average);
```

<br>
<br>
<br>


#### Transformar em Map

Imagine que voce deseja pegar 2 campos de uma lista e transformar em um `HashMap<>`

‚úèÔ∏è Pegue os campos "name" and "salary" e os coloque em um `HashMap<String, Double>`

```java
Map<String, Double> listinhaBolada = people.stream()
	.collect(Collectors.toMap( 
		p -> p.getName(),
		p -> p.getSalary()
	));

System.out.println(" ===== Chaves =====");
listinhaBolada.forEach((chave, valor) -> {System.out.println(chave);});


System.out.println("\n ===== Valores =====");
listinhaBolada.forEach((chave, valor) -> {System.out.println(chave);});


System.out.println("\n ===== Tudo junto =====");
listinhaBolada.forEach((chave,valor) -> {
	System.out.println(String.format("{%s = %.2f}",chave,valor));
});
```

Basicamente, n√≥s fizemos o seguinte:

- Abstra√≠mos a lista para uma `.stream()`
- Transformamos essa stream em um `Map<>`
	- Perceba que esse method `toMap()` recebe como parametro 2 functional interfaces. Logo, precisamos escrever 2 lambda expressions:
		- lambda expression 1 -> Keys
		- lambda expression 2 -> values


Dale. Depois, √© s√≥ usar o for each e printar.
	
No `forEach()` do HashMap, voce precisa passar 2 parametros (key and value).



<hr>
<br>

## Entendendo por baixo dos panos

Todos os method de `stream()` s√£o method que recebem como parametro uma `functional interfaces`. Ou seja, voce pode preencher esses methods, utilizando lambda.


Para compreender melhor, vamos usar o method `.filter()` como exemplo:

- O method `.filter()` recebe como parametro um objeto do tipo `Predicate`.
- `Predicate` nada mais √© do que uma `Functional Interface`.
- Essa function Interface possui, obviamente, apenas 1 abstract method.
- Logo, o `.filter()` recebe como parametro um lambda, preenchendo esse abstract method.

Sacou???

√â s√≥ pensar assim... Sempre que voce for usar um dos methods de `stream()`, saiba que eles recebem como parametro uma functional interface. Entao, sempre que voce for utiliz√°-los, use `lambda`.

Se tiver com d√∫vida de qual argumento um method precisa, basta olhar o abstract method e verificar as informacoes.
- Esse method recebe quantos parametros?
- Esse method retorna algo ou ele √© void?

Sacou?

<br>
<br>

### Praticando:

#### filter()

Seguindo a l√≥gica:

- O method `.filter()` recebe como parametro uma functional interface, chamada `Predicate`
- Essa functional interface possui, obviamente, apenas 1 abstract method.
- Esse abstract method recebe como parametro apenas um objeto generico e retorna um booleano. Se for true, o item continua na lista, senao, sai da lista
- Logo... Podemos declarar o corpo desse abstract method diretamente.

```java
System.out.println("\n ============== Teste 1 ==============");
people.stream()
	.filter(p ->{ //informamos o parametro
		if(p.getAge() >= 30){
			return true; //retornamos um boleano
		}
		return false;
	})
	.forEach(System.out::println);



System.out.println("\n ============== Teste 2 ==============");
people.stream()
	.filter(p -> {return true;}) //Informamos o parametro generica, representando cada item da lista, retornamos um booleano
	.forEach(System.out::println);




System.out.println("\n ============== Teste 3 ==============");
people.stream()
	.filter(p -> p.getAge() >= 30)
	.forEach(System.out::println);

```

Se ligou?? Basicamente, o abstract method recebe como parametro um objeto generico, que representa cada item da lista, e retorna um booleano.

Foi isso que fizemos. Nos 3 exemplos acima, n√≥s informamos um parametro e retornamos um booleano.



<br>
<br>

#### sort()

Aqui, vamos fazer o mesmo. Se nao sabemos o que passar de argumento, vamos verificar:

- O method `.sorted()` recebe como parametro uma functional interface, chamada `Comparator`.
- Essa functional interface possui, obviamente, apenas 1 abstract method.
- Esse abstract method recebe como parametro 2 objetos e retorna um Integer.
- Voal√°! Podemos usar lambda para preencher o corpo desse abstract method.


```java
System.out.println("========= forma 1: =========");
people.stream()
	.map(p -> p) //queremos o objeto completo
	.sorted((person1, person2) -> {
		return Integer.compare(person1.getAge(), person2.getAge());}
		)
	.forEach(p -> System.out.println(p.toString()));


	
	System.out.println("========= forma 2: =========");
	people.stream()
	.map(p -> p) //queremos o objeto completo
	.sorted((person1, person2) -> {
		if(person1.getAge() > person2.getAge()){
			return 1;
		}
		if(person1.getAge() < person2.getAge()){
			return -1;
		}
		return 0;
	})  
	.forEach(System.out::println);



	System.out.println("========= forma 3: =========");
	people.stream()
		.map(p -> p) //queremos o objeto completo
		.sorted((p1, p2) -> {return Integer.compare(p1.getAge(), p2.getAge());})
		.forEach(i -> System.out.println(i.toString()));
```

Sacou????? Isso √© `stream()` + `lambda`, rap√°!
